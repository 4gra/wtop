#!/usr/bin/python

cmd_options = """
A handy tool for sophisticated, ad-hoc analysis of webserver logs.

Useage:
logrep  [-m top | grep | agg | tail] [-i URL_CLASSES | -e URL_CLASSES] 
        [-g PATTERN] [-v PATTERN] [-o FIELDS] [-f FILTERS] [-q]
        [-b GROUP_BY] [-l LAST_N] [-H | -R] [-c CFG_FILE] [LOG_FILE]

   -m MODE           There are four modes:
                       - "grep" parses an entire log file (default).
                       - "tail" tails and parses the current log.
                       - "agg" calculates min(), avg(), count(*), etc
                       - "top" shows running performance statistics.

   -H, -R            Shorthand for a useful but incomplete filter of 
                     robot user-agents. -H means humans only, -R means
                     robots only. Equivalent to -f 'bot=0' or 'bot=1'.
                     Also see the bot and botname fields below.


   -i, -e CLASSES    filter by or exclude the given "classes". You can
                     configure logrep to group requests by a set of 
                     regular expressions. By default it groups them by
                     root directory. -i and -e are mutually exclusive. 
                     See the installation docs for how to configure your 
                     own classes, and the -c option, below.

                     Examples: 
                       -i home,search,wiki
                       -e img,xml,js


   -g, -v PATTERN    filter by or exclude *whole log lines* that match
                     the given regexps. You can have as many -g and -v 
                     arguments as you like.

                     Example: All lines matching "googlebot" or "msnbot" 
                              AND not "paris-hilton"
                       -g "Googlebot|msnbot" -v "Paris-Hilton"


   -f FILTERS        -f filters act on fields instead of the whole line. 
                     There is support for strings & numbers, greater 
                     than (>), less than (<), equals (=), not-equals 
                     (!=), and regular expression match (~ and !~).

                     For example: Filter successful requests that were 
                     over 10kB in size and do NOT have 'example.com' 
                     in the Referer field: 

                        -f "status=200,bytes>10000,ref!~example.com" 

                     Available fields:
                        msec       millisecond response time
                        ip         The IP *or* hostname of the client
                        ipcnt      # of hits from the same IP address
                        url        The path of the request, eg '/home'
                        ref        'Referer' header
                        bytes      Bytes sent 
                        ua         User-agent header
                        uas        First 30 characters of ua
                        ts         Unix timestamp of the request
                        class      The URL 'class'
                        status     HTTP status code, eg 200, 301, 404
                        proto      Protocol version, eg 'HTTP/1.1'
                        method     HTTP method, eg 'GET', 'POST'
                        bot        Is a robot? 1 or 0. Only a guess.
                        botname    eg 'Googlebot', 'Nutch', 'Slurp', etc
                        cc         ISO-639 country code (see below)
                        country    country name (see Geocoding, below)


   -o FIELDS         Output only the given fields. 
                      
                     Example:
                       -o 'ts,bytes,msec,url'

                     In -m agg mode you can use aggregate functions
                     very similar to SQL:

                        avg(FIELD)
                        min(FIELD)
                        max(FIELD)
                        count(*)
                        sum(FIELD)

                     Example:
                        -o 'class,count(*),avg(msec)'

                     At the moment you cannot use aggregate functions
                     in the -f FILTER. This will be in a future release.


   -b GROUP_BY       (agg mode only) fields by which to group lines.


   -l LAST_N         (grep and agg modes only) Scan the last N log lines


   -c CFG_FILE       Feed logrep a custom config file. By default it 
                     will use /etc/wtop.cfg


   -q                Quiet mode. Does not print messages to stderr.


 Geocoding:
    logrep will use the MaxMind GeoIP library if it is installed. This
    will enable two extra fields for filtering and output: country 
    (eg "United Kingdom"), and cc (country code, eg "UK"). These are a
    *guess* at the country the HTTP client is from.

 Examples:
 
 "wtop" for all human traffic:   

     logrep -m top -f 'bot=0' access.log


 Status code & response times for all Googlebot homepage hits:

     logrep -m grep -f 'botname=Googlebot' -i home -o status,msec


 Tail for pages about Angelina Jolie or Brad Pitt sent from example.com

     logrep -m tail -f 'url~jolie|pitt,ref~example.com' access.log


 Get maximum response size and average response time for requests 
 grouped by URL class:

     logrep -m agg -o 'class,max(bytes),avg(msec)' -b 'class'


14 July 2008        carlos@bueno.org       http://code.google.com/p/wtop
"""

import logrep



def runit():
    from sets import Set
    import getopt, sys, os.path
    opts, args = getopt.getopt(sys.argv[1:], "q?hHRdm:i:e:o:g:v:l:f:c:b:")
    grep_excludes = []
    grep_filters = []
    last_n = None
    filter_classes = []
    exclude_classes = []
    cond_filter = None
    cond_filter_fields = []
    filter_string = []
    output_fields = None
    MODE = 'grep' # tail, top, grep, top-json
    cfg = '/etc/wtop.cfg'
    agg_fields = []
    has_agg = False
    group_by = []
        
    for o,v in opts:
        if o == '-h' or o == '-?': print cmd_options; sys.exit(0)
        if o == '-m': MODE = v
        if o == '-i': filter_classes = Set(v.split(','))
        if o == '-e': exclude_classes = Set(v.split(','))
        if o == '-b': group_by = Set(v.split(','))
        if o == '-o': output_fields, agg_fields, has_agg = logrep.compile_aggregates(v)
        if o == '-H': filter_string.append('bot=0')
        if o == '-R': filter_string.append('bot=1')
        if o == '-g': grep_filters.append(v)
        if o == '-v': grep_excludes.append(v)
        if o == '-l': last_n = int(v)
        if o == '-f': filter_string.append(v)
        if o == '-d': logrep.LOG_LEVEL = 2
        if o == '-q': logrep.LOG_LEVEL = 0
        if o == '-c': 
            if v:
                if not os.path.exists(v):
                    raise Exception("bad config file: '%s'" % v)
                cfg = v
                
    ## check all the config options are sane, etc.
    logrep.configure(cfg)

    if not output_fields:
        output_fields = logrep.DEFAULT_OUTPUT_FIELDS

    if filter_string:
        cond_filter, cond_filter_fields = logrep.compile_filter(','.join(filter_string))

    if logrep.LOG_LEVEL == 2:
        print logrep.LOG_PATTERN, MODE, filter_classes, exclude_classes, output_fields, grep_filters, grep_excludes, args

    if ('country' in output_fields or 'cc' in output_fields) and (not logrep.geocoder):
        raise Exception("error: can't load geoip library and you asked for cc or country fields.")

    if has_agg and MODE != 'agg':
        raise Exception("error: aggregate functions are only allowed in -m agg mode")

    if not has_agg and MODE == 'agg':
        raise Exception("error: you are in -m agg mode but no aggregate functions in (%s)" % ','.join(output_fields))

    if group_by and MODE != 'agg':
        logrep.warn("warn: -b GROUP_BY is only relevant in -m agg mode")

    if not group_by and MODE == 'agg':
        logrep.warn("warn: you are in -m agg mode without -b GROUP_BY. Only one line will be printed.")

    if last_n and MODE not in ('agg', 'grep'):
        logrep.warn("warn: -l LAST_N is only relevant in -m agg or -m grep modes")


    # open the log(s) as a generator that yields raw lines
    log = None
    if MODE in ('top', 'tail', 'rrd'):
        if not args:
            log = logrep.follow(open(logrep.latest_log()[0]))
        else:
            log = logrep.follow(open(args[0]))

    else: # grep/agg mode
        logfiles = None
        if not args or args[0] == 'today' or args[0] == 't':
            logfiles = logrep.todays_logs()

        elif args[0] == 'yesterday' or args[0] == 'y':
            logfiles = logrep.yesterdays_logs()

        else: # explicit file
            logfiles = [args[0]] #logfiles = logs_for_date(args[0])

        if last_n:
            log = logrep.tail_n(logfiles[-1], last_n)
        else:       
            log = logrep.gen_cat(logrep.gen_open(logfiles))


    # various raw log line filters
    for e in grep_excludes: log = logrep.line_exclude(log, e)
    for f in grep_filters:  log = logrep.line_filter(log, f)

    # determine which fields are really necessary
    absolutely_necessary = ('ua', 'proto', 'url', 'method')
    if MODE == 'top':
        absolutely_necessary = ('status', 'ip', 'proto', 'url', 'method', 'msec', 'ua', 'ts')

    relevant_fields = Set(
        tuple(output_fields) + 
        tuple(cond_filter_fields) + 
        absolutely_necessary)

    # check to see if any derived timestamp fields like year or month are 
    # being asked for
    if filter((lambda f: f in logrep.TS_FIELDS), relevant_fields):
        relevant_fields.add('ts')

    # recompile the log format regexp given the relevant fields
    LOG_PATTERN,LOG_COLUMNS = logrep.format2regexp(logrep.config.get('main', 'log_format'), relevant_fields)

    # parse the raw log lines into records & do any needed massage and derivation
    reqs = logrep.apache_log(log, LOG_PATTERN, LOG_COLUMNS, relevant_fields)

    # determine the URL class and do any class filtering necessary
    reqs = logrep.classify_req(reqs, filter_classes, exclude_classes)

    # apply the -f filter function, if it exists
    if cond_filter: reqs = cond_filter(reqs)
    
    # feed the surviving records into the proper mode function
    try:
        if MODE=='top':
            logrep.apache_top_mode(reqs)

        elif MODE == 'rrd':
            logrep.rrd_mode(reqs)

        elif MODE == 'agg':
            logrep.agg_mode(reqs, agg_fields, group_by)

        # tail OR grep mode
        else:
            logrep.tail_mode(reqs, output_fields)

    except KeyboardInterrupt:
        sys.stderr.write("Interrupted! Mein leiben!\n")
        

if __name__ == '__main__':
#    import cProfile; cProfile.run('runit()')
    runit()
